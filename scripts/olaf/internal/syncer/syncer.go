package syncer

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	githubx "github.com/amadeus-xdlc/genai.olaf/scripts/olaf/internal/githubx"
)

type Repo struct {
	Owner  string
	Name   string
	Branch string
}

// CopyDir recursively copies a directory tree from src to dst.
func CopyDir(src, dst string) error {
    info, err := os.Stat(src)
    if err != nil { return err }
    if !info.IsDir() { return fmt.Errorf("source is not a directory: %s", src) }
    if err := os.MkdirAll(dst, 0o755); err != nil { return err }
    entries, err := os.ReadDir(src)
    if err != nil { return err }
    for _, e := range entries {
        sPath := filepath.Join(src, e.Name())
        dPath := filepath.Join(dst, e.Name())
        if e.IsDir() {
            if err := CopyDir(sPath, dPath); err != nil { return err }
        } else {
            b, err := os.ReadFile(sPath)
            if err != nil { return err }
            if err := os.MkdirAll(filepath.Dir(dPath), 0o755); err != nil { return err }
            // Preserve read-only as 0644; executables will be handled elsewhere if needed
            if err := os.WriteFile(dPath, b, 0o644); err != nil { return err }
        }
    }
    return nil
}

// GenerateIndexFrom builds the query-competency-index.md content from manifests under a specific competencies root.
func GenerateIndexFrom(compIDs []string, collectionName string, competenciesRoot string) (string, error) {
    ts := time.Now().Format("20060102-1504")
    var entries []string
    for _, comp := range compIDs {
        manPath := filepath.Join(competenciesRoot, comp, "competency-manifest.json")
        b, err := os.ReadFile(manPath)
        if err != nil { continue }
        var m struct {
            EntryPoints []struct {
                ID       string   `json:"id"`
                File     string   `json:"file"`
                Protocol string   `json:"protocol"`
                Aliases  []string `json:"aliases"`
            } `json:"entry_points"`
        }
        if json.Unmarshal(b, &m) != nil { continue }
        for _, ep := range m.EntryPoints {
            proto := strings.TrimSpace(ep.Protocol)
            if proto == "" { proto = "Act" }
            var fileRel string
            if strings.TrimSpace(ep.File) != "" { fileRel = ep.File } else if strings.TrimSpace(ep.ID) != "" { fileRel = path.Join("prompts", ep.ID+".md") } else { continue }
            full := comp + "/" + fileRel
            aliases := ""
            if len(ep.Aliases) > 0 {
                var q []string
                for _, a := range ep.Aliases { q = append(q, fmt.Sprintf("\"%s\"", a)) }
                aliases = strings.Join(q, ", ")
            }
            entries = append(entries, fmt.Sprintf("  [{%s}, \"%s\", \"%s\"]", aliases, full, proto))
        }
    }
    sb := &strings.Builder{}
    fmt.Fprintf(sb, "<olaf-query-competency-index>\n# Competency Index\n\n")
    fmt.Fprintf(sb, "**Last Updated:** %s CEDT\n\n", ts)
    fmt.Fprintf(sb, "**Collection:** %s\n\n", collectionName)
    fmt.Fprintf(sb, "**Generated By:** olaf (Go)\n\n")
    fmt.Fprintf(sb, "## Collection Information\n\n- **Name:** %s\n- **Competencies Included:** %s\n- **Total Entry Points:** %d\n\n", collectionName, strings.Join(compIDs, ", "), len(entries))
    fmt.Fprintf(sb, "## Mappings\n\n[\n%s\n]\n\nend-of-competency-index\n</olaf-query-competency-index>\n", strings.Join(entries, "\n"))
    return sb.String(), nil
}

// SyncScripts copies only the scripts listed in scripts/olaf-script.json into the local scripts/ directory.
// Entries in the manifest are paths relative to the scripts/ folder root (e.g., "now/bin/tool.exe").
// Strict branch behavior: read manifest and files from r.Branch only (same-branch rule). Missing manifest results in no-op.
func SyncScripts(r Repo, token string) error {
    // Fetch manifest from scripts folder root on the same branch
    manifest := path.Join("scripts", "olaf-script.json")
    br := strings.TrimSpace(r.Branch)
    if br == "" { return nil }
    mb, err := githubx.GetRaw(githubx.Repo{Owner: r.Owner, Name: r.Name}, manifest, br, token)
    if err != nil { return nil }
    var m struct { Scripts []string `json:"scripts"` }
    if err := json.Unmarshal(mb, &m); err != nil { return err }
    for _, rel := range m.Scripts {
        rel = strings.TrimSpace(rel)
        if rel == "" { continue }
        remote := path.Join("scripts", rel)
        content, err := githubx.GetRaw(githubx.Repo{Owner: r.Owner, Name: r.Name}, remote, br, token)
        if err != nil { continue }
        local := filepath.Join(".olaf", "scripts", rel)
        if err := WriteFileAtomic(local, content); err != nil { return err }
        if !strings.HasSuffix(strings.ToLower(local), ".exe") {
            _ = os.Chmod(local, 0o755)
        }
    }
    return nil
}

// DownloadDir recursively downloads a directory tree from a repo
func DownloadDir(r Repo, srcPath, dst, token string) error {
	entries, err := githubx.ListDir(githubx.Repo{Owner: r.Owner, Name: r.Name}, srcPath, r.Branch, token)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(dst, 0o755); err != nil { return err }
	for _, e := range entries {
		target := filepath.Join(dst, e.Name)
		switch e.Type {
		case "file":
			b, err := githubx.GetRaw(githubx.Repo{Owner: r.Owner, Name: r.Name}, e.Path, r.Branch, token)
			if err != nil { return err }
			if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil { return err }
			if err := os.WriteFile(target, b, 0o644); err != nil { return err }
		case "dir":
			if err := DownloadDir(r, e.Path, target, token); err != nil { return err }
		}
	}
	return nil
}

// GenerateIndex builds the query-competency-index.md content from local manifests
func GenerateIndex(compIDs []string, collectionName string) (string, error) {
	ts := time.Now().Format("20060102-1504")
	var entries []string
	for _, comp := range compIDs {
		manPath := filepath.Join(".olaf", "olaf-core", "competencies", comp, "competency-manifest.json")
		b, err := os.ReadFile(manPath)
		if err != nil { continue }
		var m struct {
			EntryPoints []struct {
				ID       string   `json:"id"`
				File     string   `json:"file"`
				Protocol string   `json:"protocol"`
				Aliases  []string `json:"aliases"`
			} `json:"entry_points"`
		}
		if json.Unmarshal(b, &m) != nil { continue }
		for _, ep := range m.EntryPoints {
			proto := strings.TrimSpace(ep.Protocol)
			if proto == "" { proto = "Act" }
			var fileRel string
			if strings.TrimSpace(ep.File) != "" { fileRel = ep.File } else if strings.TrimSpace(ep.ID) != "" { fileRel = path.Join("prompts", ep.ID+".md") } else { continue }
			full := comp + "/" + fileRel
			aliases := ""
			if len(ep.Aliases) > 0 {
				var q []string
				for _, a := range ep.Aliases { q = append(q, fmt.Sprintf("\"%s\"", a)) }
				aliases = strings.Join(q, ", ")
			}
			entries = append(entries, fmt.Sprintf("  [{%s}, \"%s\", \"%s\"]", aliases, full, proto))
		}
	}
	sb := &strings.Builder{}
	fmt.Fprintf(sb, "<olaf-query-competency-index>\n# Competency Index\n\n")
	fmt.Fprintf(sb, "**Last Updated:** %s CEDT\n\n", ts)
	fmt.Fprintf(sb, "**Collection:** %s\n\n", collectionName)
	fmt.Fprintf(sb, "**Generated By:** olaf (Go)\n\n")
	fmt.Fprintf(sb, "## Collection Information\n\n- **Name:** %s\n- **Competencies Included:** %s\n- **Total Entry Points:** %d\n\n", collectionName, strings.Join(compIDs, ", "), len(entries))
	fmt.Fprintf(sb, "## Mappings\n\n[\n%s\n]\n\nend-of-competency-index\n</olaf-query-competency-index>\n", strings.Join(entries, "\n"))
	return sb.String(), nil
}

// RefreshCommands regenerates /olaf-* prompt and workflow files based on manifests
func RefreshCommands(compIDs []string) error {
	compMap := map[string]string{}
	for _, comp := range compIDs {
		manPath := filepath.Join(".olaf", "olaf-core", "competencies", comp, "competency-manifest.json")
		b, err := os.ReadFile(manPath)
		if err != nil { continue }
		var m struct { EntryPoints []struct { ID, File string } `json:"entry_points"` }
		if json.Unmarshal(b, &m) != nil { continue }
		for _, ep := range m.EntryPoints {
			var fileRel string
			if strings.TrimSpace(ep.File) != "" { fileRel = ep.File } else if strings.TrimSpace(ep.ID) != "" { fileRel = path.Join("prompts", ep.ID+".md") } else { continue }
			full := filepath.ToSlash(filepath.Join("olaf-core", "competencies", comp, fileRel))
			name := ep.ID
			if name == "" { name = strings.TrimSuffix(filepath.Base(fileRel), ".md") }
			compMap[name] = full
		}
	}
	if err := recreateCommandDir(".github/prompts", ".prompt.md", compMap); err != nil { return err }
	if err := recreateCommandDir(".windsurf/workflows", ".md", compMap); err != nil { return err }
	return nil
}

func recreateCommandDir(dir, ext string, compMap map[string]string) error {
	entries, _ := os.ReadDir(dir)
	for _, e := range entries {
		if strings.HasPrefix(e.Name(), "olaf-") && strings.HasSuffix(e.Name(), ext) {
			_ = os.Remove(filepath.Join(dir, e.Name()))
		}
	}
	for name, file := range compMap {
		p := filepath.Join(dir, fmt.Sprintf("olaf-%s%s", name, ext))
		var content string
		if ext == ".prompt.md" {
			content = fmt.Sprintf("\nExecute the `%s` competency.\n", file)
		} else {
			content = fmt.Sprintf("---\ndescription: %s\nauto_execution_mode: 2\n---\n\nExecute the `%s` competency.\n", strings.ReplaceAll(name, "-", " "), file)
		}
		if err := os.WriteFile(p, []byte(content), 0o644); err != nil { return err }
	}
	return nil
}

// UpdateCopilot prepends the first non-empty line from repo's copilot instructions to local file
func UpdateCopilot(r Repo, token string, verbose bool) error {
	if verbose {
		fmt.Printf("[trace] copilot: REMOTE %s/%s@%s path=%s\n", r.Owner, r.Name, r.Branch, ".github/copilot-instructions.md")
	}
	b, err := githubx.GetRaw(githubx.Repo{Owner: r.Owner, Name: r.Name}, ".github/copilot-instructions.md", r.Branch, token)
	if err != nil { return err }
	s := bufio.NewScanner(strings.NewReader(string(b)))
	var first string
	for s.Scan() { t := strings.TrimSpace(s.Text()); if t != "" { first = t; break } }
	local := ".github/copilot-instructions.md"
    existingBytes, _ := os.ReadFile(local)
    existing := string(existingBytes)
    // Find local first non-empty line
    lines := strings.Split(existing, "\n")
    firstIdx := -1
    localFirst := ""
    for i, ln := range lines {
        if strings.TrimSpace(ln) != "" {
            firstIdx = i
            localFirst = strings.TrimSpace(ln)
            break
        }
    }
    if firstIdx >= 0 && localFirst == first {
        if verbose {
            fmt.Printf("[trace] copilot: first already present, skip write\n")
        }
        return nil
    }
    var newContent string
    if firstIdx >= 0 {
        // Replace the first non-empty line with the remote one
        lines[firstIdx] = first
        newContent = strings.Join(lines, "\n")
        if verbose {
            fmt.Printf("[trace] copilot: replaced first line\n")
        }
    } else {
        // No non-empty line found; prepend the remote first line
        newContent = first + "\n" + existing
        if verbose {
            fmt.Printf("[trace] copilot: prepended first line\n")
        }
    }
    if verbose {
        fmt.Printf("[trace] copilot: first=\"%s\"\n", first)
        abs, _ := filepath.Abs(local)
        fmt.Printf("[trace] copilot: write %s\n", abs)
    }
    return WriteFileAtomic(local, []byte(newContent))
}

// SyncBootstrap replaces bootstrap-olaf.md files from repo
func SyncBootstrap(r Repo, token string, verbose bool) error {
    files := []string{
        ".windsurf/rules/olaf-bootstrap.md",
        ".kiro/steering/olaf-bootstrap.md",
    }
	for _, f := range files {
		// Try preferred branch, then common fallbacks
		branches := []string{ strings.TrimSpace(r.Branch), "main", "master" }
		var content []byte
		for _, br := range branches {
			if br == "" { continue }
			if verbose { fmt.Printf("[trace] bootstrap: TRY %s/%s@%s path=%s\n", r.Owner, r.Name, br, f) }
			if b, err := githubx.GetRaw(githubx.Repo{Owner: r.Owner, Name: r.Name}, f, br, token); err == nil {
				content = b
				if verbose { fmt.Printf("[trace] bootstrap: OK %s/%s@%s path=%s\n", r.Owner, r.Name, br, f) }
				break
			}
		}
		// If not found in any branch, skip silently (best-effort)
		if content == nil {
			if verbose { fmt.Printf("[trace] bootstrap: MISS %s (all branches)\n", f) }
			continue
		}
		if err := os.MkdirAll(filepath.Dir(f), 0o755); err != nil { return err }
		if verbose {
			abs, _ := filepath.Abs(f)
			fmt.Printf("[trace] bootstrap: write %s\n", abs)
		}
		if err := WriteFileAtomic(f, content); err != nil { return err }
	}
	return nil
}

// EnsureGitExclude ensures local git excludes contain olaf patterns
func EnsureGitExclude() error {
	p := filepath.Join(".git", "info", "exclude")
	if err := os.MkdirAll(filepath.Dir(p), 0o755); err != nil { return err }
	var cur string
	if b, err := os.ReadFile(p); err == nil { cur = string(b) }
	need := []string{ 
		".windsurf/workflows/olaf-*.md", 
		".github/prompts/olaf-*.prompt.md",
		".olaf/",
	}
	for _, line := range need {
		if !containsLine(cur, line) { cur += ensureNewline(cur) + line + "\n" }
	}
	return WriteFileAtomic(p, []byte(cur))
}

func containsLine(s, needle string) bool {
	for _, ln := range strings.Split(s, "\n") { if strings.TrimSpace(ln) == needle { return true } }
	return false
}

func ensureNewline(s string) string {
	if s == "" || strings.HasSuffix(s, "\n") { return "" }
	return "\n"
}

// CleanCompetencies removes the entire managed competencies directory
func CleanCompetencies() error {
	return os.RemoveAll(filepath.Join(".olaf", "olaf-core", "competencies"))
}

// CleanReference removes the entire managed reference directory
func CleanReference() error {
	return os.RemoveAll(filepath.Join(".olaf", "olaf-core", "reference"))
}

// CleanCommands removes generated olaf-* prompt/workflow files
func CleanCommands() error {
	// Use recreateCommandDir with an empty map to just delete matching files
	if err := recreateCommandDir(".github/prompts", ".prompt.md", map[string]string{}); err != nil { return err }
	if err := recreateCommandDir(".windsurf/workflows", ".md", map[string]string{}); err != nil { return err }
	return nil
}

// WriteFileAtomic writes content to a temporary file then renames it into place.
func WriteFileAtomic(target string, content []byte) error {
    tmp := target + ".tmp"
    if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil { return err }
    if err := os.WriteFile(tmp, content, 0o644); err != nil { return err }
    return os.Rename(tmp, target)
}

// ReplaceDirAtomic removes dst and renames src into place (best-effort; both must be on same volume)
func ReplaceDirAtomic(src, dst string) error {
    // Prepare
    if err := os.MkdirAll(filepath.Dir(dst), 0o755); err != nil { return err }
    
    // Remove destination if it exists (Windows-friendly approach)
    if ok, _ := dirExists(dst); ok {
        if err := os.RemoveAll(dst); err != nil {
            return fmt.Errorf("failed to remove destination %s: %w", dst, err)
        }
    }
    
    // Copy source to destination
    if err := CopyDir(src, dst); err != nil {
        return fmt.Errorf("failed to copy %s to %s: %w", src, dst, err)
    }
    
    // Remove temporary source directory
    if err := os.RemoveAll(src); err != nil {
        // Non-fatal: destination is already in place
        fmt.Printf("Warning: failed to remove temporary directory %s: %v\n", src, err)
    }
    
    return nil
}

func dirExists(p string) (bool, error) {
    fi, err := os.Stat(p)
    if err != nil {
        if os.IsNotExist(err) { return false, nil }
        return false, err
    }
    return fi.IsDir(), nil
}

// RecreateCommandDirAtomic generates olaf-* files into a tmp dir then swaps them in.
func RecreateCommandDirAtomic(dir, ext string, compMap map[string]string) error {
    tmpDir := dir + ".tmp-olaf"
    _ = os.RemoveAll(tmpDir)
    if err := os.MkdirAll(tmpDir, 0o755); err != nil { return err }
    for name, file := range compMap {
        p := filepath.Join(tmpDir, fmt.Sprintf("olaf-%s%s", name, ext))
        var content string
        if ext == ".prompt.md" {
            content = fmt.Sprintf("\nExecute the `%s` competency.\n", file)
        } else {
            content = fmt.Sprintf("---\ndescription: %s\nauto_execution_mode: 2\n---\n\nExecute the `%s` competency.\n", strings.ReplaceAll(name, "-", " "), file)
        }
        if err := os.WriteFile(p, []byte(content), 0o644); err != nil { return err }
    }
    // Remove old matching files
    entries, _ := os.ReadDir(dir)
    for _, e := range entries {
        if strings.HasPrefix(e.Name(), "olaf-") && strings.HasSuffix(e.Name(), ext) {
            _ = os.Remove(filepath.Join(dir, e.Name()))
        }
    }
    // Move new files into dir
    news, _ := os.ReadDir(tmpDir)
    for _, e := range news {
        if err := os.Rename(filepath.Join(tmpDir, e.Name()), filepath.Join(dir, e.Name())); err != nil { return err }
    }
    return os.RemoveAll(tmpDir)
}

// RefreshCommandsAtomic regenerates /olaf-* files atomically
func RefreshCommandsAtomic(compIDs []string) error {
    compMap := map[string]string{}
    for _, comp := range compIDs {
        manPath := filepath.Join(".olaf", "olaf-core", "competencies", comp, "competency-manifest.json")
        b, err := os.ReadFile(manPath)
        if err != nil { continue }
        var m struct { EntryPoints []struct { ID, File string } `json:"entry_points"` }
        if json.Unmarshal(b, &m) != nil { continue }
        for _, ep := range m.EntryPoints {
            var fileRel string
            if strings.TrimSpace(ep.File) != "" { fileRel = ep.File } else if strings.TrimSpace(ep.ID) != "" { fileRel = path.Join("prompts", ep.ID+".md") } else { continue }
            full := filepath.ToSlash(filepath.Join("olaf-core", "competencies", comp, fileRel))
            name := ep.ID
            if name == "" { name = strings.TrimSuffix(filepath.Base(fileRel), ".md") }
            compMap[name] = full
        }
    }
    if err := RecreateCommandDirAtomic(".github/prompts", ".prompt.md", compMap); err != nil { return err }
    if err := RecreateCommandDirAtomic(".windsurf/workflows", ".md", compMap); err != nil { return err }
    return nil
}
