#!/usr/bin/env python3
"""
CVE Tasklist Update Script

Generates separate tasklists for CVE descriptors and analyses based on completion status.
Based on PowerShell update-tasklist.ps1 from OLAF toolkit.

This script processes BlackDuck CSV data and generates tasklists for CVE management,
tracking completion status of descriptors and analyses.
"""

import argparse
import csv
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class CVETasklistManager:
    """Manages CVE tasklist generation and tracking."""
    
    def __init__(self, project_root: Path):
        """
        Initialize CVE tasklist manager.
        
        Args:
            project_root: Root directory of the project workspace
        """
        self.project_root = project_root
        self.severity_order = {"Critical": 1, "High": 2, "Medium": 3, "Low": 4}
    
    def read_json_safe(self, file_path: Path) -> Optional[Dict]:
        """
        Safely read JSON file with error handling.
        
        Args:
            file_path: Path to JSON file
            
        Returns:
            Parsed JSON data or None if error
        """
        try:
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Failed to read JSON from {file_path}: {e}")
        return None
    
    def test_cve_descriptor(self, cve_id: str) -> bool:
        """
        Check if CVE descriptor exists.
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2021-1234)
            
        Returns:
            True if descriptor exists
        """
        descriptor_path = (self.project_root / 
                          "ads/findings/cve-verifier/individual-cve-descriptors" / 
                          f"{cve_id}-descriptor.json")
        return descriptor_path.exists()
    
    def test_cve_analysis(self, cve_id: str) -> bool:
        """
        Check if CVE analysis exists.
        
        Args:
            cve_id: CVE identifier
            
        Returns:
            True if analysis exists
        """
        analysis_dir = (self.project_root / 
                       "ads/findings/cve-verifier/individual-cve-analyses")
        
        if not analysis_dir.exists():
            return False
        
        # Look for analysis files with pattern: <project_name>_<CVE-ID>-analysis.json
        pattern = f"*_{cve_id}-analysis.json"
        analysis_files = list(analysis_dir.glob(pattern))
        return len(analysis_files) > 0
    
    def get_cve_classification(self, cve_id: str) -> str:
        """
        Get CVE classification from analysis file.
        
        Args:
            cve_id: CVE identifier
            
        Returns:
            Classification string or "PENDING" if not found
        """
        analysis_dir = (self.project_root / 
                       "ads/findings/cve-verifier/individual-cve-analyses")
        
        if not analysis_dir.exists():
            return "PENDING"
        
        # Look for analysis files with pattern: <project_name>_<CVE-ID>-analysis.json
        pattern = f"*_{cve_id}-analysis.json"
        analysis_files = list(analysis_dir.glob(pattern))
        
        if analysis_files:
            analysis = self.read_json_safe(analysis_files[0])
            if (analysis and 
                analysis.get('executive_summary') and 
                analysis['executive_summary'].get('risk_classification')):
                return analysis['executive_summary']['risk_classification']
        
        return "PENDING"
    
    def load_blackduck_data(self, csv_path: Path) -> List[Dict]:
        """
        Load and process BlackDuck CSV data.
        
        Args:
            csv_path: Path to BlackDuck CSV file
            
        Returns:
            List of CVE data dictionaries
        """
        try:
            with open(csv_path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                blackduck_data = list(reader)
        except (IOError, csv.Error) as e:
            raise ValueError(f"Error reading BlackDuck CSV: {e}")
        
        # Extract unique CVE-dependency mappings
        cve_data = []
        seen_cves = set()
        
        for row in blackduck_data:
            cve = row.get('CVE', '').strip()
            if cve and cve.startswith('CVE-') and cve not in seen_cves:
                cve_data.append({
                    'CVE': cve,
                    'Component': row.get('Library', '').strip(),
                    'Version': row.get('Version', '').strip(),
                    'Severity': row.get('Severity', '').strip(),
                    'DependencyStatus': 'CONFIRMED_PRESENT'
                })
                seen_cves.add(cve)
        
        # Sort by CVE ID
        cve_data.sort(key=lambda x: x['CVE'])
        
        print(f"Found {len(cve_data)} unique CVE entries from BlackDuck CSV")
        return cve_data
    
    def categorize_cves(self, cve_data: List[Dict], tasklist_type: str) -> Tuple[List[Dict], List[Dict]]:
        """
        Categorize CVEs into completed and pending based on tasklist type.
        
        Args:
            cve_data: List of CVE data dictionaries
            tasklist_type: Either "Descriptor" or "Analysis"
            
        Returns:
            Tuple of (completed, pending) CVE lists
        """
        completed = []
        pending = []
        
        for cve in cve_data:
            has_descriptor = self.test_cve_descriptor(cve['CVE'])
            has_analysis = self.test_cve_analysis(cve['CVE'])
            classification = self.get_cve_classification(cve['CVE'])
            
            status = {
                **cve,
                'HasDescriptor': has_descriptor,
                'HasAnalysis': has_analysis,
                'Classification': classification
            }
            
            # Determine completion based on tasklist type
            if tasklist_type == "Descriptor":
                status['IsCompleted'] = has_descriptor
                status['NextAction'] = "Descriptor Complete" if has_descriptor else "Create Descriptor"
            elif tasklist_type == "Analysis":
                status['IsCompleted'] = has_analysis
                status['NextAction'] = "Analysis Complete" if has_analysis else "Create Analysis"
            
            if status['IsCompleted']:
                completed.append(status)
            else:
                pending.append(status)
        
        # Sort pending by severity (Critical first, then High, then Medium/Low)
        pending.sort(key=lambda x: (self.severity_order.get(x['Severity'], 5), x['CVE']))
        
        return completed, pending
    
    def generate_tasklist_content(self, tasklist_type: str, blackduck_csv: str, 
                                 cve_data: List[Dict], completed: List[Dict], 
                                 pending: List[Dict]) -> str:
        """
        Generate tasklist markdown content.
        
        Args:
            tasklist_type: Type of tasklist ("Descriptor" or "Analysis")
            blackduck_csv: Path to BlackDuck CSV file
            cve_data: All CVE data
            completed: Completed CVEs
            pending: Pending CVEs
            
        Returns:
            Formatted markdown content
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        total_cves = len(cve_data)
        completed_count = len(completed)
        pending_count = len(pending)
        progress = round((completed_count / total_cves) * 100, 1) if total_cves > 0 else 0
        
        tasklist_title = "CVE Descriptor Creation" if tasklist_type == "Descriptor" else "CVE Analysis"
        
        content = [
            f"# CVE {tasklist_title} Tasklist - jal-dapi-ext",
            f"**Generated**: {timestamp}",
            f"**Type**: {tasklist_type}",
            f"**Source**: {blackduck_csv}",
            "",
            "## Summary",
            f"- **Total CVEs**: {total_cves}",
            f"- **Completed**: {completed_count}",
            f"- **Pending**: {pending_count}",
            f"- **Progress**: {progress}%",
            ""
        ]
        
        # Add classification summary for Analysis tasklists
        if tasklist_type == "Analysis":
            content.extend(["## Classification Summary", ""])
            
            classification_counts = {}
            for cve in completed:
                classification = cve['Classification']
                if classification and classification.strip() and classification != "PENDING":
                    classification_counts[classification] = classification_counts.get(classification, 0) + 1
            
            if classification_counts:
                for classification, count in classification_counts.items():
                    content.append(f"- **{classification}**: {count}")
            else:
                content.append("- **No completed analyses yet**")
            content.append("")
        
        # Add completed section
        completed_icon = "📄" if tasklist_type == "Descriptor" else "✅"
        content.extend([
            f"## Completed {tasklist_type} {completed_icon}",
            "| CVE | Component | Severity | Status | Date |",
            "|-----|-----------|----------|--------|------|"
        ])
        
        for cve in completed:
            status_text = "Descriptor Created" if tasklist_type == "Descriptor" else cve['Classification']
            content.append(f"| {cve['CVE']} | {cve['Component']} | {cve['Severity']} | {status_text} | - |")
        
        if not completed:
            content.append(f"| - | - | - | No completed {tasklist_type.lower()}s yet | - |")
        
        # Add pending section
        content.extend([
            "",
            f"## Pending {tasklist_type} (Priority Order)",
            "| CVE | Component | Severity | Has Descriptor | Next Action |",
            "|-----|-----------|----------|----------------|-------------|"
        ])
        
        for cve in pending:
            descriptor_status = "✅" if cve['HasDescriptor'] else "❌"
            content.append(f"| {cve['CVE']} | {cve['Component']} | {cve['Severity']} | {descriptor_status} | {cve['NextAction']} |")
        
        if not pending:
            content.append(f"| - | - | - | - | All {tasklist_type.lower()}s completed |")
        
        # Add next recommended CVE
        if pending:
            next_cve = pending[0]
            content.extend([
                "",
                "## Next Recommended CVE",
                f"**{next_cve['CVE']}** - {next_cve['Component']} ({next_cve['Severity']} priority)"
            ])
            
            if tasklist_type == "Descriptor":
                content.append(f"- Path: individual-cve-descriptors/{next_cve['CVE']}-descriptor.json")
            else:
                content.extend([
                    f"- Descriptor: individual-cve-descriptors/{next_cve['CVE']}-descriptor.json",
                    f"- Analysis: individual-cve-analyses/{next_cve['CVE']}-analysis.json"
                ])
        
        # Add usage instructions
        content.extend([
            "",
            "## Usage Instructions",
            f"1. **For completed CVEs**: Check files in individual-cve-{tasklist_type.lower()}s/",
            "2. **For pending CVEs**: Follow priority order above",
            f'3. **Update this list**: Run update-tasklist.py --type {tasklist_type} --blackduck-csv "{blackduck_csv}"'
        ])
        
        # Add file locations
        content.extend(["", "## File Locations"])
        if tasklist_type == "Descriptor":
            content.extend([
                "- **Descriptors**: `olaf-data/findings/cve-verifier/individual-cve-descriptors/`",
                "- **Global Index**: `olaf-data/findings/cve-verifier/global-cve-index.json`"
            ])
        else:
            content.extend([
                "- **Descriptors**: `olaf-data/findings/cve-verifier/individual-cve-descriptors/`",
                "- **Analyses**: `olaf-data/findings/cve-verifier/individual-cve-analyses/`",
                "- **Summary**: `olaf-data/findings/cve-verifier/cve-exposure-analysis-summary.md`"
            ])
        
        return "\n".join(content)
    
    def auto_detect_workspace(self) -> Optional[Path]:
        """
        Auto-detect workspace root by looking for ack and ads folders.
        
        Returns:
            Path to workspace root or None if not found
        """
        current_dir = Path.cwd()
        search_dir = current_dir
        
        # Look for workspace indicators (ack and ads folders)
        while search_dir != search_dir.parent:
            ack_path = search_dir / "ack"
            ads_path = search_dir / "ads"
            
            if ack_path.exists() and ads_path.exists():
                return search_dir
            
            search_dir = search_dir.parent
        
        return None


def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description="Generate CVE tasklists based on completion status",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --type Descriptor --blackduck-csv blackduck.csv
  %(prog)s --type Analysis --blackduck-csv data.csv --project-root /path/to/workspace
        """
    )
    
    parser.add_argument(
        '--type', '--tasklist-type',
        choices=['Descriptor', 'Analysis'],
        required=True,
        help='Type of tasklist to generate'
    )
    
    parser.add_argument(
        '--blackduck-csv',
        required=True,
        help='Path to BlackDuck CSV file'
    )
    
    parser.add_argument(
        '--project-root',
        help='Path to project workspace root (auto-detected if not provided)'
    )
    
    args = parser.parse_args()
    
    # Validate BlackDuck CSV file
    blackduck_csv = Path(args.blackduck_csv)
    if not blackduck_csv.exists():
        print(f"Error: BlackDuck CSV file not found: {blackduck_csv}", file=sys.stderr)
        sys.exit(1)
    
    # Auto-detect or validate project root
    if args.project_root:
        project_root = Path(args.project_root).resolve()
        if not project_root.exists():
            print(f"Error: Project root does not exist: {project_root}", file=sys.stderr)
            sys.exit(1)
    else:
        manager_temp = CVETasklistManager(Path.cwd())
        project_root = manager_temp.auto_detect_workspace()
        if not project_root:
            print("Error: Could not auto-detect workspace root. Please provide --project-root parameter", file=sys.stderr)
            print("Looking for workspace containing 'ack' and 'ads' folders.", file=sys.stderr)
            sys.exit(1)
        print(f"Auto-detected workspace root: {project_root}")
    
    # Initialize manager
    manager = CVETasklistManager(project_root)
    
    try:
        # Load and process data
        cve_data = manager.load_blackduck_data(blackduck_csv)
        completed, pending = manager.categorize_cves(cve_data, args.type)
        
        # Generate content
        content = manager.generate_tasklist_content(
            args.type, str(blackduck_csv), cve_data, completed, pending
        )
        
        # Save output file
        output_path = (project_root / 
                      f"ads/findings/cve-verifier/jal-dapi-ext-cve-tasklist-{args.type}.md")
        
        # Create output directory if needed
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"Generated {args.type} tasklist: {output_path}")
        print(f"Total CVEs: {len(cve_data)}, Completed: {len(completed)}, Pending: {len(pending)}")
        
        if pending:
            next_cve = pending[0]
            print(f"Next recommended: {next_cve['CVE']} ({next_cve['Component']}, {next_cve['Severity']})")
        
    except Exception as e:
        print(f"Error during analysis: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()