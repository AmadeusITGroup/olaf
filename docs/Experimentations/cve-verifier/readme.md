# CVE Verifier

## Chapter 0: Conclusions

- The CVE Verifier workflow allows creating CVE descriptors, then to do the exposure analysis on current code using these descriptors
- It currently works only with Windsurf and Claude Sonnet 4 (or Sonnet 4 Thinking)
- It requires a human all along with security and language (e.g., Java)expertise to verify outcomes - unless we improve and test it to the point where we become 100% confident about the results
- **Potential or recommended optimizations**:
  - The generation of CVE descriptors should be parallelized to improve time efficiency
  - CVE descriptors cost about 20 cents each to produce, so they could be valuable resources to share across many projects
  - The workflow currently expects human intervention to restart agent sessions with fresh context. This is not the optimal user experience. We should consider implementing the same workflow in Langchain/Langraph, provided we have access to Sonnet 4 (or future equivalent or better models)
  - We believe tools such as Aider or Claude Code or Roo-code could also deliver the workflow more efficiently, but we don't have resources to test this hypothesis


## Chapter 1: What the CVE Verifier Does

The CVE Verifier is a comprehensive automated workflow designed for analyzing Common Vulnerabilities and Exposures (CVEs) in codebases. It follows a systematic approach to identify, describe, and analyze potential security vulnerabilities present in your project's dependencies.

### Core Workflows

The CVE Verifier consists of three main workflows that operate sequentially:

1. **Extract CVE Descriptors** - This step creates comprehensive CVE descriptor files by gathering information from multiple authoritative sources - NIST, MITRE etc. For each CVE, it:
   - Researches vulnerability information from at least 3 authoritative sources
   - Documents affected versions, vulnerable components, and exploitation methods
   - Creates standardized descriptor files that can be used for automated analysis
   - Generates and embeds into the descriptor file a set of search patterns that will be used during the analysis phase to grep into the codebase
   - Updates a global CVE index for easy reference

2. **Generate Code Files** - This step consolidates the codebase into searchable text files:
   - Creates `llms-full.txt` with complete code content
   - Creates `llms.txt` with a more concise version
   - These files make it easier to perform pattern-based searches in subsequent steps

   **Note : we did this as we where not sure of the target final agent and its ability to index and embed code correctly. It may prove too cumbersome and may have to be taken out.**



3. **Analyze CVE Exposure** - The final step performs in-depth analysis of each CVE:
   - Uses patterns from the descriptor files to search for vulnerable code, currently from the llms-full.txt (cf. note above).
   - Examines import patterns, method invocations, configurations, and more
   - Classifies risk into specific categories: DIRECTLY_EXPOSED, POTENTIALLY_EXPOSED, LOW_RISK, or NOT_EXPOSED
   - Generates detailed analysis Json reports with evidence and recommendations

### Key Features

- **Dependency-Aware Analysis**: Focuses on CVEs that affect actual dependencies in your project
- **Multi-Source Research**: Gathers information from 6+ authoritative sources for each CVE
- **Evidence-Based Classification**: Risk levels are assigned based on concrete evidence of code patterns
- **Comprehensive Documentation**: Creates detailed descriptors and analysis files in standardized formats
- **Prioritized Workflow**: Processes CVEs in order of severity, focusing on critical issues first

## Chapter 2: Approach and Implementation

### Prerequisites

To use the CVE Verifier, you'll need:

1. **BlackDuck Analysis Output CSV File**
   - This file contains information about dependencies and associated CVEs in your project
   - The CSV must include at least the following columns: CVE, Library, Version, and Severity
   - The file should be placed in the `ads/findings/cve-verifier/` directory with the name `blackduck_cve.csv`

### Installation in OLAF

Check (or get) the following files:

- **Workflow Prompts** in `ack/prompts/cve-verifier/`:
  - `cve-analysis-workflow.md` - Main workflow orchestration prompt
  - `analyze-cve-exposure.md` - Analysis prompt for evaluating CVEs
  - `generate-cve-descriptor.md` - Prompt for creating CVE descriptors

- **Schema Templates** in `ack/templates/cve-verifier/`:
  - `cve-descriptor-schema.json` - Schema for validating CVE descriptors
  - `cve-analysis-template.json` - Template for analysis reports
  - `global-cve-index-template.json` - Template for global CVE index

- **Utility Scripts** in `ack/tools/cve-verifier/`:
  - `generate-llms-txt.ps1` - Creates consolidated code files
  - `update-tasklist.ps1` - Updates task completion status


- **Windsurf Configuration** (usually in `/ack/reference/work-protocols/default/.windsurf`):
  - Add the CVE analysis workflow to your query competency index

### Using the CVE Verifier

1. **Prepare Your Environment**:
   - Ensure the BlackDuck CSV file is available

2. **Start the Workflow**:
   - Close all opened files
   - In Cascade, enter either "cve exposure" or `/use-competency cve exposure`
   - You can also open the workflow (from `/ack/prompts/cve-verifier/`) and say "execute this workflow"

3. **Reviewing Results**:
   - CVE descriptors will be created in `/ads/findings/cve-verifier/individual-cve-descriptors/`
   - Analysis reports will be created in `/ads/findings/cve-verifier/individual-cve-analyses/`
   - Tasklists will be generated to track progress in `/ads/findings/cve-verifier/`
   - A global index file will provide an overview of all CVEs in `/ads/findings/cve-verifier/`

### Important Files and Directories

- `blackduck_cve.csv` - Input file with CVE data from BlackDuck
- `global-cve-index.json` - Index of all CVEs with paths to descriptor files
- `jal-dapi-ext-cve-tasklist-Descriptor.md` - Tracks progress of descriptor creation
- `jal-dapi-ext-cve-tasklist-Analysis.md` - Tracks progress of CVE analysis
- `llms-full.txt` and `llms.txt` - Consolidated code files for pattern searching


### Testing with Agent and Models

- Up to now (August 2025), only Windsurf Cascade with Sonnet 4 (or Thinking) has delivered correctly on the Descriptors and Analysis.
- It works to some extent with models such as Sonnet 3.7 and Gemini 2.5 Pro. The descriptors are not as complex as with Sonnet 4 (note that this may still be sufficient, but we couldn't verify due to our lack of security expertise).
- We tested only with Java solutions - it should work with other languages as well.

**Important note**: Despite significant effort and adapting the prompts and workflows, we could not make this work with GitHub Copilot agent, even using Sonnet 4. This is consistent with many other attempts for different complex workflows similar to this one.

### Best Practices

1. **Follow the Workflow Sequence**: Always complete steps in the prescribed order
2. **Complete Each Step Fully**: Don't skip ahead before completing the current step
3. **Verify Prerequisites**: Ensure all required files exist before starting
4. **Review Tasklists**: Check the tasklists to see which CVEs need attention next
5. **Document Sources**: Always include at least 6 authoritative sources for each CVE descriptor
6. **Provide Evidence**: Document all searches and findings in the analysis reports

By following these guidelines, you can effectively use the CVE Verifier to identify and manage security vulnerabilities in your codebase.
